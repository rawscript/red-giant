<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Giant Protocol - Web Integration Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .demo-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .demo-card:hover {
            transform: translateY(-5px);
        }

        .demo-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .chat-container {
            display: none;
            margin-top: 15px;
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
        }

        .message.own {
            background: #667eea;
            color: white;
            margin-left: auto;
        }

        .message.other {
            background: white;
            border: 1px solid #e1e5e9;
        }

        .message-meta {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            margin-top: 10px;
        }

        .file-item {
            padding: 10px;
            border-bottom: 1px solid #e1e5e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #333;
        }

        .file-meta {
            font-size: 0.8rem;
            color: #666;
        }

        .connection-status {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .connection-status h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        #aiResponse {
            display: none;
            background: #f8f9fa;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            min-height: 100px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Red Giant Protocol</h1>
            <p>Web Integration Demo - High-Performance P2P Communication</p>
        </div>

        <!-- Connection Status -->
        <div class="connection-status">
            <h3>üîó Connection Status</h3>
            <div class="form-group">
                <label for="serverUrl">Server URL:</label>
                <input type="text" id="serverUrl" value="http://localhost:8080" placeholder="Enter Red Giant server URL">
            </div>
            <button class="btn" onclick="connectToServer()">Connect</button>
            <button class="btn btn-secondary" onclick="disconnectFromServer()">Disconnect</button>
            <button class="btn btn-secondary" onclick="toggleAutoRefresh()">Toggle Auto-Refresh</button>
            <div id="connectionInfo"></div>
            
            <!-- Network Statistics -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="statThroughput">0.00</div>
                    <div class="stat-label">Throughput (MB/s)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statLatency">0</div>
                    <div class="stat-label">Latency (ms)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statRequests">0</div>
                    <div class="stat-label">Total Requests</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statUptime">0</div>
                    <div class="stat-label">Uptime (s)</div>
                </div>
            </div>
        </div>

        <div class="demo-grid">
            <!-- File Upload/Download Demo -->
            <div class="demo-card">
                <h3>üìÅ File Upload & Download</h3>
                <div class="form-group">
                    <label for="fileInput">Select File:</label>
                    <input type="file" id="fileInput">
                </div>
                <button class="btn" onclick="uploadFile()">Upload File</button>
                <button class="btn btn-secondary" onclick="listFiles()">List Files</button>
                <div id="uploadStatus"></div>
                <div id="fileList" class="file-list"></div>
            </div>

            <!-- Real-time Chat Demo -->
            <div class="demo-card">
                <h3>üí¨ Real-time Chat</h3>
                <div class="form-group">
                    <label for="chatUsername">Username:</label>
                    <input type="text" id="chatUsername" placeholder="Enter your username">
                </div>
                <div class="form-group">
                    <label for="chatRoom">Room:</label>
                    <input type="text" id="chatRoom" value="general" placeholder="Enter room name">
                </div>
                <button class="btn" onclick="joinChat()">Join Chat</button>
                <button class="btn btn-danger" onclick="leaveChat()">Leave Chat</button>
                
                <div id="chatContainer" class="chat-container">
                    <div id="chatMessages" class="chat-messages"></div>
                    <div class="form-group">
                        <input type="text" id="messageInput" placeholder="Type your message..." onkeypress="handleChatKeyPress(event)">
                    </div>
                    <button class="btn" onclick="sendMessage()">Send Message</button>
                </div>
            </div>

            <!-- IoT Data Streaming Demo -->
            <div class="demo-card">
                <h3>üì° IoT Data Streaming</h3>
                <div class="form-group">
                    <label for="deviceId">Device ID:</label>
                    <input type="text" id="deviceId" value="sensor-001" placeholder="Enter device ID">
                </div>
                <div class="form-group">
                    <label for="sensorType">Sensor Type:</label>
                    <select id="sensorType">
                        <option value="temperature">Temperature</option>
                        <option value="humidity">Humidity</option>
                        <option value="pressure">Pressure</option>
                        <option value="accelerometer">Accelerometer</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="streamInterval">Interval (ms):</label>
                    <input type="number" id="streamInterval" value="1000" min="100" max="10000">
                </div>
                <button class="btn" onclick="startIoTStreaming()">Start Streaming</button>
                <button class="btn btn-danger" onclick="stopIoTStreaming()">Stop Streaming</button>
                <div id="iotStatus"></div>
                <div id="iotStats"></div>
            </div>

            <!-- AI Token Streaming Demo -->
            <div class="demo-card">
                <h3>ü§ñ AI Token Streaming</h3>
                <div class="form-group">
                    <label for="aiModel">AI Model:</label>
                    <select id="aiModel">
                        <option value="gpt-4">GPT-4</option>
                        <option value="claude-3">Claude-3</option>
                        <option value="llama-2">Llama-2</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="aiPrompt">Prompt:</label>
                    <textarea id="aiPrompt" rows="3" placeholder="Enter your AI prompt...">Explain quantum computing in simple terms</textarea>
                </div>
                <div class="form-group">
                    <label for="tokensPerSecond">Tokens/Second:</label>
                    <input type="number" id="tokensPerSecond" value="50" min="1" max="200">
                </div>
                <button class="btn" onclick="startAIStreaming()">Generate Response</button>
                <button class="btn btn-danger" onclick="stopAIStreaming()">Stop Generation</button>
                <div id="aiStats"></div>
                <div id="aiResponse"></div>
            </div>
        </div>
    </div>

    <!-- Include Red Giant JavaScript SDK -->
    <script src="../javascript/redgiant.js"></script>
    
    <script>
        // Global variables
        let redGiantClient = null;
        let chatRoom = null;
        let iotDevice = null;
        let aiTokenStream = null;
        let statsInterval = null;
        let aiStreamingActive = false;

        // Connection Functions
        async function connectToServer() {
            const serverUrl = document.getElementById('serverUrl').value;
            
            try {
                redGiantClient = new RedGiantClient(serverUrl);
                await redGiantClient.healthCheck();
                
                showStatus('connectionInfo', `‚úÖ Connected to ${serverUrl}`, 'success');
                
                // Start auto-refresh of stats
                refreshStats();
                
            } catch (error) {
                showStatus('connectionInfo', `‚ùå Connection failed: ${error.message}`, 'error');
                redGiantClient = null;
            }
        }

        function disconnectFromServer() {
            if (redGiantClient) {
                // Clean up active connections
                if (chatRoom) leaveChat();
                if (iotDevice) stopIoTStreaming();
                if (statsInterval) clearInterval(statsInterval);
                
                redGiantClient = null;
                showStatus('connectionInfo', 'üîå Disconnected from server', 'info');
                
                // Reset stats
                document.getElementById('statThroughput').textContent = '0.00';
                document.getElementById('statLatency').textContent = '0';
                document.getElementById('statRequests').textContent = '0';
                document.getElementById('statUptime').textContent = '0';
            }
        }

        // File Upload/Download Functions
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }

            if (!redGiantClient) {
                showStatus('uploadStatus', 'Not connected to server', 'error');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                const result = await redGiantClient.uploadData(uint8Array, file.name);
                
                showStatus('uploadStatus', 
                    `‚úÖ Uploaded ${file.name} (${result.throughput_mbps.toFixed(2)} MB/s)`, 'success');
                
                // Refresh file list
                setTimeout(listFiles, 1000);
                
            } catch (error) {
                showStatus('uploadStatus', `Upload failed: ${error.message}`, 'error');
            }
        }

        async function listFiles() {
            if (!redGiantClient) return;

            try {
                const files = await redGiantClient.searchFiles('');
                const fileListEl = document.getElementById('fileList');
                
                if (files.length === 0) {
                    fileListEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No files found</div>';
                    return;
                }

                fileListEl.innerHTML = files.map(file => `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-meta">${file.size} bytes ‚Ä¢ ${new Date(file.uploaded_at).toLocaleString()}</div>
                        </div>
                        <button class="btn" onclick="downloadFile('${file.id}', '${file.name}')">Download</button>
                    </div>
                `).join('');
                
            } catch (error) {
                showStatus('uploadStatus', `Failed to list files: ${error.message}`, 'error');
            }
        }

        async function downloadFile(fileId, fileName) {
            if (!redGiantClient) return;

            try {
                const data = await redGiantClient.downloadData(fileId);
                
                // Create download link
                const blob = new Blob([data]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('uploadStatus', `‚úÖ Downloaded ${fileName}`, 'success');
            } catch (error) {
                showStatus('uploadStatus', `Download failed: ${error.message}`, 'error');
            }
        }

        // Chat Functions
        function joinChat() {
            const username = document.getElementById('chatUsername').value;
            const roomId = document.getElementById('chatRoom').value;
            
            if (!username || !roomId) {
                alert('Please enter username and room name');
                return;
            }

            if (!redGiantClient) {
                alert('Not connected to server');
                return;
            }

            // Create a simple chat room implementation using Red Giant
            chatRoom = {
                roomId: roomId,
                username: username,
                active: true,
                pollInterval: setInterval(async () => {
                    if (!chatRoom.active) return;
                    
                    try {
                        // Search for new messages in this room
                        const files = await redGiantClient.searchFiles(`chat_${roomId}_`);
                        const recentFiles = files.filter(f => 
                            new Date(f.uploaded_at) > new Date(Date.now() - 10000) // Last 10 seconds
                        );
                        
                        for (const file of recentFiles) {
                            const data = await redGiantClient.downloadData(file.id);
                            const message = JSON.parse(new TextDecoder().decode(data));
                            if (message.from !== username) { // Don't show own messages
                                displayChatMessage(message);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to poll messages:', error);
                    }
                }, 2000),
                
                sendMessage: async (content) => {
                    const message = {
                        id: `msg_${Date.now()}_${Math.random()}`,
                        from: username,
                        to: roomId,
                        content: content,
                        timestamp: new Date().toISOString(),
                        type: 'public'
                    };
                    
                    const data = new TextEncoder().encode(JSON.stringify(message));
                    const filename = `chat_${roomId}_${message.id}.json`;
                    
                    try {
                        await redGiantClient.uploadData(data, filename);
                    } catch (error) {
                        console.error('Failed to send message:', error);
                    }
                },
                
                leave: () => {
                    chatRoom.active = false;
                    if (chatRoom.pollInterval) {
                        clearInterval(chatRoom.pollInterval);
                    }
                }
            };
            document.getElementById('chatContainer').style.display = 'block';
            
            displayChatMessage({
                from: 'system',
                content: `Joined room "${roomId}" as ${username}`,
                timestamp: new Date().toISOString(),
                type: 'system'
            });
        }

        function leaveChat() {
            if (chatRoom) {
                chatRoom.leave();
                chatRoom = null;
                document.getElementById('chatContainer').style.display = 'none';
                document.getElementById('chatMessages').innerHTML = '';
            }
        }

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            
            if (!message || !chatRoom) return;

            chatRoom.sendMessage(message);
            messageInput.value = '';
            
            // Display own message immediately
            displayChatMessage({
                from: document.getElementById('chatUsername').value,
                content: message,
                timestamp: new Date().toISOString(),
                type: 'public',
                own: true
            });
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function displayChatMessage(message) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${message.own ? 'own' : 'other'}`;
            
            const time = new Date(message.timestamp).toLocaleTimeString();
            const sender = message.type === 'system' ? 'üîî' : message.from;
            
            messageEl.innerHTML = `
                <div>${message.content}</div>
                <div class="message-meta">${sender} ‚Ä¢ ${time}</div>
            `;
            
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // IoT Streaming Functions
        function startIoTStreaming() {
            const deviceId = document.getElementById('deviceId').value;
            const sensorType = document.getElementById('sensorType').value;
            const interval = parseInt(document.getElementById('streamInterval').value);
            
            if (!redGiantClient) {
                showStatus('iotStatus', 'Not connected to server', 'error');
                return;
            }

            // Create a simple IoT device simulator using Red Giant
            iotDevice = {
                deviceId: deviceId,
                sensorType: sensorType,
                interval: interval,
                active: false,
                batchCount: 0,
                
                startStreaming: () => {
                    iotDevice.active = true;
                    iotDevice.streamInterval = setInterval(async () => {
                        if (!iotDevice.active) return;
                        
                        // Generate sensor reading
                        const reading = {
                            device_id: deviceId,
                            sensor_type: sensorType,
                            value: iotDevice.generateSensorValue(sensorType),
                            unit: iotDevice.getSensorUnit(sensorType),
                            timestamp: new Date().toISOString(),
                            location: {
                                latitude: 40.7128 + (Math.random() - 0.5) * 0.01,
                                longitude: -74.0060 + (Math.random() - 0.5) * 0.01,
                                altitude: Math.random() * 100
                            },
                            metadata: {
                                battery_level: 85 + Math.random() * 15,
                                signal_strength: -60 + Math.random() * 20,
                                firmware: "v1.2.3"
                            }
                        };
                        
                        // Update UI
                        updateIoTStats(reading);
                        
                        // Upload reading
                        try {
                            const data = new TextEncoder().encode(JSON.stringify(reading));
                            const filename = `iot_${deviceId}_${Date.now()}.json`;
                            await redGiantClient.uploadData(data, filename);
                            
                            iotDevice.batchCount++;
                            showStatus('iotStatus', 
                                `üì° Reading ${iotDevice.batchCount} uploaded from ${deviceId}`, 'success');
                        } catch (error) {
                            console.error('Failed to upload IoT reading:', error);
                        }
                    }, interval);
                },
                
                stopStreaming: () => {
                    iotDevice.active = false;
                    if (iotDevice.streamInterval) {
                        clearInterval(iotDevice.streamInterval);
                    }
                },
                
                generateSensorValue: (type) => {
                    switch (type) {
                        case 'temperature': return 20 + Math.random() * 15; // 20-35¬∞C
                        case 'humidity': return 30 + Math.random() * 40; // 30-70%
                        case 'pressure': return 1000 + Math.random() * 50; // 1000-1050 hPa
                        case 'light': return Math.random() * 1000; // 0-1000 lux
                        default: return Math.random() * 100;
                    }
                },
                
                getSensorUnit: (type) => {
                    switch (type) {
                        case 'temperature': return '¬∞C';
                        case 'humidity': return '%';
                        case 'pressure': return 'hPa';
                        case 'light': return 'lux';
                        default: return 'units';
                    }
                }
            };

            iotDevice.startStreaming();
            showStatus('iotStatus', `üöÄ Started streaming ${sensorType} data from ${deviceId}`, 'info');
        }

        function stopIoTStreaming() {
            if (iotDevice) {
                iotDevice.stopStreaming();
                iotDevice = null;
                showStatus('iotStatus', '‚èπÔ∏è Streaming stopped', 'info');
                document.getElementById('iotStats').innerHTML = '';
            }
        }

        function updateIoTStats(reading) {
            const statsEl = document.getElementById('iotStats');
            statsEl.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${reading.value.toFixed(2)}</div>
                        <div class="stat-label">${reading.sensor_type} (${reading.unit})</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${reading.metadata.battery_level.toFixed(1)}%</div>
                        <div class="stat-label">Battery</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${reading.metadata.signal_strength.toFixed(0)}</div>
                        <div class="stat-label">Signal (dBm)</div>
                    </div>
                </div>
            `;
        }

        // AI Token Streaming Functions
        function startAIStreaming() {
            const model = document.getElementById('aiModel').value;
            const prompt = document.getElementById('aiPrompt').value;
            const tokensPerSec = parseInt(document.getElementById('tokensPerSecond').value);
            
            if (!prompt.trim()) {
                alert('Please enter a prompt');
                return;
            }

            if (!redGiantClient) {
                showStatus('aiStats', 'Not connected to server', 'error');
                return;
            }

            const sessionId = `web_session_${Date.now()}`;
            const responseEl = document.getElementById('aiResponse');
            responseEl.style.display = 'block';
            responseEl.innerHTML = '<div style="color: #667eea;">ü§ñ Generating response...</div>';
            
            // Create a simple AI token stream simulator using Red Giant
            const simulatedResponse = generateSimulatedResponse(prompt);
            const tokens = simulatedResponse.split(' ');
            aiStreamingActive = true;
            
            aiTokenStream = {
                sessionId: sessionId,
                model: model,
                tokens: tokens,
                currentToken: 0,
                
                start: () => {
                    const interval = 1000 / tokensPerSec; // ms per token
                    
                    aiTokenStream.streamInterval = setInterval(async () => {
                        if (!aiStreamingActive || aiTokenStream.currentToken >= tokens.length) {
                            clearInterval(aiTokenStream.streamInterval);
                            showStatus('aiStats', 
                                `‚úÖ Response complete! ${tokens.length} tokens streamed`, 'success');
                            aiStreamingActive = false;
                            return;
                        }
                        
                        const token = {
                            id: `token_${sessionId}_${aiTokenStream.currentToken}`,
                            session_id: sessionId,
                            token: tokens[aiTokenStream.currentToken],
                            position: aiTokenStream.currentToken,
                            timestamp: new Date().toISOString(),
                            metadata: {
                                confidence: 0.95,
                                token_type: 'word',
                                model_name: model,
                                temperature: 0.7
                            }
                        };
                        
                        // Upload token
                        try {
                            const data = new TextEncoder().encode(JSON.stringify(token));
                            const filename = `ai_token_${sessionId}_${aiTokenStream.currentToken}.json`;
                            const result = await redGiantClient.uploadData(data, filename);
                            
                            // Update UI
                            const currentText = responseEl.textContent || '';
                            responseEl.textContent = currentText + token.token + ' ';
                            
                            showStatus('aiStats', 
                                `Token ${aiTokenStream.currentToken + 1} streamed (${result.throughput_mbps.toFixed(2)} MB/s)`, 'info');
                            
                            aiTokenStream.currentToken++;
                        } catch (error) {
                            console.error('Failed to stream token:', error);
                            showStatus('aiStats', `Streaming failed: ${error.message}`, 'error');
                            aiStreamingActive = false;
                            clearInterval(aiTokenStream.streamInterval);
                        }
                    }, interval);
                }
            };
            
            aiTokenStream.start();
        }

        function stopAIStreaming() {
            aiStreamingActive = false;
            if (aiTokenStream) {
                showStatus('aiStats', '‚èπÔ∏è AI streaming stopped', 'info');
            }
        }

        function generateSimulatedResponse(prompt) {
            const responses = {
                'quantum': 'Quantum computing harnesses the principles of quantum mechanics to process information in fundamentally different ways than classical computers. Instead of using bits that are either 0 or 1, quantum computers use quantum bits or qubits that can exist in superposition, meaning they can be both 0 and 1 simultaneously. This allows quantum computers to perform certain calculations exponentially faster than classical computers.',
                'machine learning': 'Machine learning is a subset of artificial intelligence that enables computers to learn and improve from experience without being explicitly programmed. It uses algorithms to analyze data, identify patterns, and make predictions or decisions. Common types include supervised learning, unsupervised learning, and reinforcement learning.',
                'blockchain': 'Blockchain is a distributed ledger technology that maintains a continuously growing list of records, called blocks, which are linked and secured using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data, making it resistant to modification and providing transparency.',
                'default': 'This is a simulated AI response demonstrating Red Giant Protocol\'s high-speed token streaming capabilities. The system can handle real-time AI model outputs with exceptional performance, delivering tokens at rates exceeding 500 MB/s through the optimized C core architecture.'
            };

            const key = Object.keys(responses).find(k => prompt.toLowerCase().includes(k)) || 'default';
            return responses[key];
        }

        // Network Statistics Functions
        async function refreshStats() {
            if (!redGiantClient) return;

            try {
                const stats = await redGiantClient.getNetworkStats();
                
                document.getElementById('statThroughput').textContent = stats.throughput_mbps.toFixed(2);
                document.getElementById('statLatency').textContent = stats.average_latency_ms;
                document.getElementById('statRequests').textContent = stats.total_requests.toLocaleString();
                document.getElementById('statUptime').textContent = stats.uptime_seconds.toLocaleString();
                
            } catch (error) {
                console.error('Failed to refresh stats:', error);
            }
        }

        function toggleAutoRefresh() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
                showStatus('connectionInfo', 'Auto-refresh disabled', 'info');
            } else {
                statsInterval = setInterval(refreshStats, 5000);
                showStatus('connectionInfo', 'Auto-refresh enabled (5s)', 'info');
            }
        }

        // Utility Functions
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
            
            // Auto-clear success messages
            if (type === 'success') {
                setTimeout(() => {
                    element.innerHTML = '';
                }, 5000);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (chatRoom) chatRoom.leave();
            if (iotDevice) iotDevice.stopStreaming();
            if (statsInterval) clearInterval(statsInterval);
        });
    </script>
</body>
</html>